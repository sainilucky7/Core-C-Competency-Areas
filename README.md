# Core-C-Competency-Areas
These are the foundational areas every solid C++ engineer should demonstrate in their work or conversation.
# Language fundamentals
•	Modern C++ usage — evidence of C++11/14/17/20 features rather than legacy C++98.
•	Memory management — smart pointers, RAII, ownership semantics.
•	Object oriented design — classes, inheritance, polymorphism used appropriately.
•	Templates & generics — understanding of template programming and STL.
# Systems & Performance Skills
C++ engineers often work close to hardware or performance critical systems.
Concurrency & multithreading
•	std::thread, mutex, atomic, condition_variable.
•	Understanding of race conditions, deadlocks, lock free patterns.
# Performance optimization
•	Profiling experience.
•	Familiarity with CPU/GPU constraints.
•	Efficient data structures and algorithms.
# Real time or low latency systems
•	Evidence of deterministic execution.
•	Experience with embedded constraints or high frequency loops.
# Domain Specific Signals
Depending on the role, look for these specialized indicators.
# Robotics / Autonomy
•	ROS or ROS2 packages.
•	SLAM, perception, sensor fusion.
•	OpenCV, PCL, Eigen, GTSAM, Ceres.
# Game engines / Graphics
•	Unreal Engine, Unity C++ plugins.
•	OpenGL, Vulkan, DirectX.
•	Physics engines.
# Embedded / Firmware
•	Bare metal C/C++.
•	RTOS (FreeRTOS, Zephyr).
•	Device drivers, microcontroller code.
# High performance computing
•	SIMD, CUDA, OpenMP.
•	Multithreaded pipelines.
•	Numerical optimization.
